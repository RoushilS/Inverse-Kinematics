# -*- coding: utf-8 -*-
"""Inverse Kinematics Final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jEyifc0Q9568SfPEVQV93oFd15340ElG

# Explanation

# Import Libraries
"""

from sklearn.metrics import accuracy_score, classification_report
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.datasets import load_iris
import matplotlib.pyplot as plt
import tensorflow as tf
import pandas as pd
import numpy as np
import math
import random

model = tf.keras.models.load_model("my_model.keras")

rows, cols = (729000, 8)
dataset = [[0]*cols]*rows
def fwd(input_list):
  current_x = 0
  current_y = 0
  out = []
  for i in range(0,int(len(input_list)/2)):
    out.append(input_list[i*2])
    out.append(input_list[i*2+1])
    current_x+=input_list[i*2]*math.cos(math.radians(input_list[i*2+1]))
    current_y+=input_list[i*2]*math.sin(math.radians(input_list[i*2+1]))
  out.append(current_x)
  out.append(current_y)
  return out

for i in range(1,3):
  for j in range(0,45,1):
    for k in range(1,3):
      for m in range(0,45,1):
        for l in range(1,3):
          for z in range(0,45,1):
              dataset[90*45*45*2*(i-1)+90*45*2*j+90*45*(k-1)+90*m+45*(l-1)+z]=fwd([i/2.5,j*2,k/2.5,m*2,l/2.5,z*2])

"""# Tensorflow Forward Kinematics"""

def forward_kinematics_3j(theta1, theta2, theta3, l1, l2, l3):
    theta12 = theta1 + theta2
    theta123 = theta12 + theta3

    x = l1 * tf.cos(theta1) + l2 * tf.cos(theta12) + l3 * tf.cos(theta123)
    y = l1 * tf.sin(theta1) + l2 * tf.sin(theta12) + l3 * tf.sin(theta123)
    return tf.stack([x, y], axis=1)

def ik_loss_3joint(x, y_true, y_pred):

    l1 = x[:, 0]
    l2 = x[:, 1]
    l3 = x[:, 2]
    target = x[:, 3:5]

    theta1 = y_pred[:, 0]
    theta2 = y_pred[:, 1]
    theta3 = y_pred[:, 2]

    pred_pos = forward_kinematics_3j(theta1, theta2, theta3, l1, l2, l3)


    distance = tf.norm(pred_pos - target, axis=1)
    return tf.reduce_mean(distance)

"""# Graphs of Test Data Don't Press

"""

data = np.array(dataset)

x = data[:, 6]
y = data[:, 7]

plt.figure(figsize=(8, 8))
plt.scatter(x, y, c='maroon', alpha=0.7, edgecolors='black')

plt.title("Scatter Plot of End Effector Final Position", fontsize=14)
plt.xlabel("X-axis", fontsize=12)
plt.ylabel("Y-axis", fontsize=12)

plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

data = np.array(dataset)

x = data[:, 0]
y = data[:, 1]

plt.figure(figsize=(8, 8))
plt.scatter(x, y, c='maroon', alpha=0.7, edgecolors='black')

plt.title("Scatter Plot of Angle and Joint Length(Useless)", fontsize=14)
plt.xlabel("X-axis", fontsize=12)
plt.ylabel("Y-axis", fontsize=12)


plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

"""# Format Data"""

import pandas as pd
from sklearn.model_selection import train_test_split


column_names = ["Joint1", "Angle1", "Joint2", "Angle2", "Joint3", "Angle3", "Output_X", "Output_Y"]

df = pd.DataFrame(dataset, columns=column_names)


X = df[["Output_X", "Output_Y", "Joint1", "Joint2", "Joint3"]].values


y = df[["Angle1", "Angle2", "Angle3"]].values


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Test"""

import tensorflow as tf
import numpy as np
import pandas as pd


def forward_kinematics(angles, link_lengths):
    angles = tf.cast(angles, tf.float32)
    link_lengths = tf.cast(link_lengths, tf.float32)
    x = tf.reduce_sum(link_lengths * tf.cos(angles), axis=1)
    y = tf.reduce_sum(link_lengths * tf.sin(angles), axis=1)
    return tf.stack([x, y], axis=1)


input_layer = tf.keras.layers.Input(shape=(5,))
x = tf.keras.layers.Dense(100, activation='relu')(input_layer)
x = tf.keras.layers.Dense(100, activation='relu')(x)
x = tf.keras.layers.Dense(100, activation='relu')(x)
predicted_angles = tf.keras.layers.Dense(3, activation='sigmoid')(x) * tf.constant(np.pi/2, dtype=tf.float32)
model = tf.keras.Model(inputs=input_layer, outputs=predicted_angles)


optimizer = tf.keras.optimizers.Adam()


@tf.function
def train_step(data_batch):
    data_batch = tf.cast(data_batch, tf.float32)
    target_pos = data_batch[:, 0:2]
    link_lengths = data_batch[:, 2:5]

    with tf.GradientTape() as tape:
        pred_angles = model(data_batch)
        pred_pos = forward_kinematics(pred_angles, link_lengths)
        target_pos = tf.cast(target_pos, tf.float32)

        squared_diff = tf.square(pred_pos - target_pos)


        loss = tf.reduce_mean(squared_diff)

    gradients = tape.gradient(loss, model.trainable_variables)
    optimizer.apply_gradients(zip(gradients, model.trainable_variables))


    distances = tf.sqrt(tf.reduce_sum(squared_diff, axis=1))
    avg_distance = tf.reduce_mean(distances)

    return loss, avg_distance, pred_angles

X = df[["Output_X", "Output_Y", "Joint1", "Joint2", "Joint3"]].values.astype(np.float32)
y = df[["Angle1", "Angle2", "Angle3"]].values.astype(np.float32)  # For validation


train_dataset = tf.data.Dataset.from_tensor_slices(X).batch(32)


model.build((None, 5))
dummy_data = tf.zeros((1, 5), dtype=tf.float32)
with tf.GradientTape() as tape:
    dummy_pred = model(dummy_data)
    dummy_loss = tf.reduce_sum(dummy_pred)
grads = tape.gradient(dummy_loss, model.trainable_variables)
optimizer.apply_gradients(zip(grads, model.trainable_variables))


PATIENCE = 5
MIN_DELTA = 1e-4
best_loss = float('inf')
patience_counter = 0

for epoch in range(100):
    epoch_loss = 0
    epoch_distance = 0
    all_pred_angles = []

    for step, data_batch in enumerate(train_dataset):
        loss, avg_distance, pred_angles = train_step(data_batch)
        epoch_loss += loss
        epoch_distance += avg_distance
        all_pred_angles.append(pred_angles)


    avg_loss = epoch_loss / (step + 1)
    avg_distance = epoch_distance / (step + 1)

    print(f"Epoch {epoch}:")
    print(f"  Loss (MSE): {avg_loss.numpy():.6f}")
    print(f"  Avg Distance: {avg_distance.numpy():.6f} units")

    sample_angles = all_pred_angles[0][0].numpy()
    print(f"  Sample predicted angles (radians): {sample_angles}")
    print(f"  Sample predicted angles (degrees): {np.degrees(sample_angles)}")


    if avg_loss < best_loss - MIN_DELTA:
        best_loss = avg_loss
        patience_counter = 0
        print("  Loss improved - resetting patience")
    else:
        patience_counter += 1
        print(f"  No improvement - patience: {patience_counter}/{PATIENCE}")

    if patience_counter >= PATIENCE:
        print(f"Early stopping triggered at epoch {epoch}")
        break

def evaluate_model(test_data, true_angles=None):
    test_data = tf.cast(test_data, tf.float32)
    pred_angles = model.predict(test_data)

    link_lengths = test_data[:, 2:5]
    pred_pos = forward_kinematics(pred_angles, link_lengths)
    target_pos = test_data[:, 0:2]


    pos_errors = tf.sqrt(tf.reduce_sum(tf.square(pred_pos - target_pos), axis=1))
    avg_pos_error = tf.reduce_mean(pos_errors)

    print(f"Evaluation Results:")
    print(f"  Average Position Error: {avg_pos_error.numpy():.4f} units")


    if true_angles is not None:
        angle_errors = np.abs(np.degrees(pred_angles) - np.degrees(true_angles))
        avg_angle_error = np.mean(angle_errors)
        print(f"  Average Angle Error: {avg_angle_error:.2f} degrees")

    return pred_angles, pred_pos

"""# Hybrid Implementation"""

import numpy as np
import time

start_time = time.perf_counter()

def forward_kinematics(theta, link_lengths):
    x = np.sum(link_lengths * np.cos(np.cumsum(theta)))
    y = np.sum(link_lengths * np.sin(np.cumsum(theta)))
    return np.array([x, y])

def jacobian(theta, link_lengths):
    n = len(theta)
    J = np.zeros((2, n))
    for i in range(n):
        J[0, i] = -np.sum(link_lengths[i:] * np.sin(np.sum(theta[:i+1])))
        J[1, i] = np.sum(link_lengths[i:] * np.cos(np.sum(theta[:i+1])))
    return J

def inverse_kinematics_jacobian(target, initial_theta, link_lengths, max_iterations, tolerance=1e-5):
    theta = initial_theta.copy()
    for _ in range(max_iterations):
        current_position = forward_kinematics(theta, link_lengths)
        error = target - current_position

        if np.linalg.norm(error) < tolerance:
            break

        J = jacobian(theta, link_lengths)
        J_inv = np.linalg.pinv(J)

        delta_theta = J_inv.dot(error)
        theta += delta_theta

    return [theta,_]

"""# Verify Pt 1."""

def generatetest(amountx):
    outs = []
    for i in range(amountx):
        trainon = dataset[random.randint(0, len(dataset) - 1)]
        outs.append([trainon[0], trainon[2], trainon[4], trainon[6], trainon[7]])

    return np.array(outs)


test_inputs = generatetest(1)
print(test_inputs.shape)

def testwithmodel(iterations):
    start_time = time.perf_counter()

    test_inputs = np.array(generatetest(1))
    predictions = model.predict(test_inputs)

    link_lengths = np.array(test_inputs[0][:3])


    initial_theta = predictions.flatten()


    target = np.array(test_inputs[0][3:5])


    final_theta, iterations = inverse_kinematics_jacobian(target, initial_theta, link_lengths, iterations)
    final_position = fwd([link_lengths[0],final_theta[0],link_lengths[1],final_theta[1],link_lengths[2],final_theta[2]])[6:]


    print(f"Initial joint angles: {initial_theta}")
    print(f"Final joint angles: {final_theta}")
    print(f"Final end-effector position: {final_position}")
    print(f"Target position: {target}")
    print(f"Lengths: {link_lengths}")
    print(f"Iterations: {iterations}")
    print(f"Error: {np.linalg.norm(final_position - target)}")

    end_time = time.perf_counter()
    elapsed_time = end_time - start_time
    print(f"Elapsed time: {elapsed_time:.1f} seconds")

testwithmodel(1)

"""# Verify Pt. 2"""

def distance(fx1,fy1,fx2,fy2):
  return ((((fx1-fx2)**2)+((fy1-fy2)**2))**0.5)
print(distance(1,1,2,2))

def errorangle(dx1,dy1,dx2,dy2):
  return math.degrees(abs(math.atan(dy1/dx1)-math.atan(dy2/dx2)))

test_inputs = np.array(generatetest(20))
predictions = model.predict(test_inputs)
x1a = []
y1a = []
x2a = []
y2a = []
anglef = []
angleerrors = []
distances = []
for i, pred in enumerate(predictions):

    points = [(0,0)]
    j1 = test_inputs[i][0]
    a1 = math.degrees(pred[0])
    print(pred)
    j2 = test_inputs[i][1]
    a2 = math.degrees(pred[1])
    j3 = test_inputs[i][2]
    a3 = math.degrees(pred[2])
    finx = test_inputs[i][3]
    finy = test_inputs[i][4]
    testx = fwd([j1,a1,j2,a2,j3,a3])[6]
    testy = fwd([j1,a1,j2,a2,j3,a3])[7]
    points.append((fwd([j1,a1])[2],fwd([j1,a1])[3]))
    points.append((fwd([j1,a1,j2,a2])[4],fwd([j1,a1,j2,a2])[5]))
    points.append((fwd([j1,a1,j2,a2,j3,a3])[6],fwd([j1,a1,j2,a2,j3,a3])[7]))
    x1a.append(finx)
    y1a.append(finy)
    x2a.append(testx)
    y2a.append(testy)
    anglef.append(a1)
    anglef.append(a2)
    anglef.append(a3)
    distances.append(distance(finx,finy,testx,testy))
    angleerrors.append(errorangle(testx,testy,finx,finy))

print(points)

distanceavg = 0
anglecenter = [0,0,0]
for z in distances:
  distanceavg+=z
distanceavg = (distanceavg/len(distances))
print(len(distances))
print(distances)
print(distanceavg)
angleerroravg = 0
for z in angleerrors:
  angleerroravg+=z
angleerroravg = (angleerroravg/len(angleerrors))
for z in range(len(anglef)):
  anglecenter[z%3]+=abs(anglef[z]-45)
anglecenter[0] = 3*anglecenter[0]/len(anglef)
anglecenter[1] = 3*anglecenter[1]/len(anglef)
anglecenter[2] = 3*anglecenter[2]/len(anglef)
print(len(angleerrors))
print(angleerrors)
print(anglecenter)
print(angleerroravg)

sumup = 0
for i in distances:
  sumup+=(i-distanceavg)**2
sumup/=len(distances)
sumup = sumup**(0.5)
print(sumup)

print("Mean Distance Error", distanceavg)
print("Mean Angle Error", angleerroravg)
print("Standard Deviation", sumup)
print("Distance from 45", anglecenter[0],anglecenter[1],anglecenter[2])

import numpy as np

# True values
y_true = np.array(y1a)

# Predicted values
y_pred = np.array(y2a)

# Calculate RMSE
rmse = np.sqrt(np.mean((y_true - y_pred)**2))

print(f"RMSE: {rmse}")

"""# Graphs"""

plt.figure(figsize=(8,8))
plt.cla()
plt.scatter(x1a, y1a, c='green', alpha=0.7, edgecolors='black')
plt.scatter(x2a, y2a, c='orange', alpha=0.7, edgecolors='black')
plt.scatter([0,3], [0,3], c='blue', alpha=0.7, edgecolors='black')

plt.title("Scatter Plot of End Effector Final Position", fontsize=14)
plt.xlabel("X-axis", fontsize=12)
plt.ylabel("Y-axis", fontsize=12)

# Grid and showing the plot
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

plt.figure(figsize=(6,6))
plt.plot()

x, y = zip(*points)
plt.scatter([0,3,finx], [0,3,finy], c='blue', alpha=0.7, edgecolors='black')
plt.plot(x, y, marker='o', linestyle='-',c="green")

"""# Stuff"""

model.save('/content/my_modelfixed.keras')

import os
print(os.path.exists("/content/my_modelfixed.keras"))

from google.colab import files
files.download('/content/my_modelfixed.keras')  # or "/content/my_model.h5"